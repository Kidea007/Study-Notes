# 嵌入式Linux C/C++笔记

form：华清远见

开发普通：Ubuntu  编译器：gcc  编辑器：Vim

---



# 环境搭建：

参考技术博客，虚拟机VMwa Workstation最新版 安装Ubuntu最新版

下面的配置是基于华清远见的课程，安装14.4版本ubuntu

### 虚拟配置:

1个1核处理器

1G内存

20G硬盘

### 硬盘分区：

/ 根目录 5G

/boot 引导程序 200M

Swap 虚拟内存（交换区） 2G

/home 用户文件 剩下的空间

---





# termina的基础命令

## Ubuntu系统teminal的常用命令

命令严格区分大小写 

ctrl+alt+t快速打开teminal

ls 打开文件夹的目录

cd 进入文件夹

cd .. 退回到上一个文件夹

ls -l 打开目录并显示文件详细信息

Cat -s -b 其中，Cat表示在teminal中查看文件内容，-s 表示合并空行，-b 表示加行序号

cp test.c test1.c 在同一文件夹把文件test.c复制为test1.c

programe 程序

---



# 数据类型

所有数据（数字、字母、字符&字符串、特殊符号）最后都会变成2进制（机器语言）

---



## 数值数据

| 十六进制 HEX | 十进制 DEC | 二进制 BIN |
| :----------: | :--------: | :--------: |
|     0x0      |    000     |    000     |
|     0x1      |    001     |    001     |
|     0x2      |    002     |    010     |
|     0x3      |    003     |    011     |
|     0x4      |    004     |    100     |
|     0x5      |    005     |    101     |
|     0x6      |    006     |    110     |
|     0x7      |    007     |    111     |
|     0x8      |    008     |    1000    |
|     0x9      |    009     |    1001    |
|     0xA      |    010     |    1010    |
|     0xB      |    011     |    1011    |
|     0xC      |    012     |    1100    |
|     0xD      |    013     |    1101    |
|     0xE      |    014     |    1110    |
|     0xF      |    015     |    1111    |
|     0x10     |    016     | 0001 0000  |
|     0x11     |    017     | 0001 0001  |
|     0x12     |    018     | 0001 0010  |
|     0x13     |    019     | 0001 0011  |
|     0x14     |    020     | 0001 0100  |
|     0x15     |    021     | 0001 0101  |
|     0x16     |    022     | 0001 0110  |
|     0x17     |    023     | 0001 0111  |
|     0x18     |    024     | 0001 1000  |
|     0x19     |    025     | 0001 1001  |
|     0x1A     |    026     | 0001 1010  |
|     0x1B     |    027     | 0001 1011  |
|              |            |            |

---



## 非数值数据

根据编码标准转化为二进制

如：ASCII码表

---





# 编译器

gcc（GNU Compiler）

调用gcc的相关SHELL指令

gcc hello.c 最基础的编译命令 生成 a.out

gcc hello.c -o hello.exe 自定义编译后的文件名

gcc hello.c -wall表示编译hello.c并生成详细的错误提示

cat hello.c 把程序打印到teminal

# shell的使用

shell工具是对操作系统的指令的封装，用于实现用户与linux内核的交互

若干shell命令行+控制语句=shell脚本

linux内核接受到shell工具转译后的指令，可以控制相关硬件执行操作

硬件执行操作后会给shell提供反馈

相当于用户通过shell工具，间接的控制了硬件

shell工具简化了linux内核指令，使操作硬件更方便快捷

## shell的类型

bash shell

zshell





## 标准IO

控制高端的硬件必须通过操作系统内核来实现

不同操作系统内核提供了不同的API接口

用库函数将常用的一些操作系统的API接口封装成统一标准的新API接口

这个新的API接口就是标准IO，如:  <stdio.h>在所有主流操作系统上使用C语言

标准IO方便了程序在不同操作系统间的移植

---



# C语言

## 01数据类型

![image-20240713101531814](../assets/嵌入式Linux CC++笔记/image-20240713101531814.png)

### bool类型

bool不是基本数据类型，需要调用<stdbool.h>中的宏定义bool

```c
#include <stdio.h>
#include <stdbool.h>
bool = not_zero = true;//非零的任何数据都识别为1
bool = zero =false;

```

不同硬件平台下相同的数据类型占用的内存大小不一样

### 基本数据类型

下面是32bit的ubuntu下的数据长度

![image-20240616114340320](../assets/嵌入式Linux CC++笔记/image-20240616114340320.png)

![image-20240616114901604](../assets/嵌入式Linux CC++笔记/image-20240616114901604.png)

![image-20240616114910197](../assets/嵌入式Linux CC++笔记/image-20240616114910197.png)

对于不同硬件平台可以调用sizeof(datetype)查看不同数据类型的长度(不是变量)

直接打开 /usr/include/limits.h也可以查看各种数据类型的长度

数据范围溢出会乱码，但是编译器不一定会报错，需要人工检查

![image-20240616115554108](../assets/嵌入式Linux CC++笔记/image-20240616115554108.png)

![image-20240616115641086](../assets/嵌入式Linux CC++笔记/image-20240616115641086.png)

### 常量



char  本质上还是int 转换的规则就是ASCII

例如：A=65 a=65+32=97

SHELL 指令 man ASCII可以查看具体转换规则

---

宏定义 常量

方便代码维护

#define A B    把A替换为B，可修改B的值，相当于复制粘贴

预处理不会占用资源

存入寄存器的变量不能取地址&，即指针不能控制

static 静态类型 

正常情况下每次循环都会销毁局部变量

static修饰的变量默认初始化为0，并且不入轮回（值不被销毁）

调用其他文件中的全局变量，需要用extern修饰这个变量

如果全局变量被static修饰，无法被extern调用

---



## 02运算符号

### 算数运算符

按照小学数学来就行

![image-20240616155454376](../assets/嵌入式Linux CC++笔记/image-20240616155454376.png)

### 关系运算符

判断0和1，即假和真，false or true

可以在括号外加 ！取反

![image-20240616154622623](../assets/嵌入式Linux CC++笔记/image-20240616154622623.png)

### ==逻辑运算符==

![image-20240616154906737](../assets/嵌入式Linux CC++笔记/image-20240616154906737.png)

逻辑与 相当于串联开关

逻辑或 相当于并联开关 

### ==位运算符号==

进行位运算时候一定要把数据转换为==二进制==

在操作寄存器配置时经常用到位操作

![image-20240616161609129](../assets/嵌入式Linux CC++笔记/image-20240616161609129.png)

位逻辑反 ：在~后的二进制数每一位都分别取反

位逻辑与：在&两侧的二进制数对应的每一位都分别进行逻辑与

位逻辑或：在|两侧的二进制数对应的每一位都分别进行逻辑或

---



==位逻辑异或==：（==异或==表示相同位0，不同为1）

对^两侧对应的每一位二进制数分别进行异或

左移位：在<<左侧是被操作的变量，右侧是操作变量向左移动的位数

```c
uchar a=0xe4, b;
b=a<<3;//a转化为二进制：1110 0100
//左移3位相当于：去掉左边3位，然后在末尾补上3位0，
//b=0010 0000
```

右移位：>>原理同上。

---

### ==赋值复合运算符==

将右边的表达式的运算结果赋值给左边的变量

![image-20240616165235551](../assets/嵌入式Linux CC++笔记/image-20240616165235551.png)

---

---



### 条件运算符

if<表达式1>为真，则执行<表达式2>，else执行<表达式3>

注意：只有表达式1是布尔型的判断

![image-20240616170100989](../assets/嵌入式Linux CC++笔记/image-20240616170100989.png)

### 逗号运算符

在括号内的表达式从左往右依次执行，将最右边的结果赋值给最左边的变量

<img src="../assets/嵌入式Linux CC++笔记/image-20240616201857238.png" alt="image-20240616201857238" style="zoom:50%;" />

### ==内存运算符号==

```c
int a = 0;
int b = 0;
int c = 0;
b = sizeof(int);//括号内填变量和数据类型，都等同数据类型
c = sizeof(a);//b=c,内存占用的大小和变量的值无关，只和数据类型有关

```

### 运算符的==优先级==

记不住的，用到再来查

![image-20240616203223348](../assets/嵌入式Linux CC++笔记/image-20240616203223348.png)

## 03输入和输出函数

来自<stdio.h>的输入输出函数

---

常量、变量、表达式从本质上都可以归纳为数据

在理解代码框架的过程中只需要关注数据的结果

得到结果的过程可以战略性忽略

### 格式输出函数：

printf(" 被打印的变量是：%格式符1，%格式符2 "，变量名1，变量名2)

不同数据类型的变量打印需要不同的格式符

<img src="../assets/嵌入式Linux CC++笔记/image-20240616205639231.png" alt="image-20240616205639231" style="zoom: 50%;" />

![image-20240616210248669](../assets/嵌入式Linux CC++笔记/image-20240616210248669.png)

![image-20240616210300084](../assets/嵌入式Linux CC++笔记/image-20240616210300084.png)

![image-20240616210434410](../assets/嵌入式Linux CC++笔记/image-20240616210434410.png)

<img src="../assets/嵌入式Linux CC++笔记/image-20240616210509771.png" alt="image-20240616210509771" style="zoom: 33%;" />





![image-20240616214552947](../assets/嵌入式Linux CC++笔记/image-20240616214552947.png)





# day10 软件包管理及shell命令

```shell
打开终端Terminal快捷键   

Ctrl+Alt+t
```

Linux大概的体系结构

![image-20240716201052114](../assets/Linux-C学习笔记/image-20240716201052114.png)



## 软件包

### 软件包的类型

- **Binary Packages**（二进制软件包）：它包含可执行文件、==库文件==、配置文件、man/info页面、版权声明和其它文档。

- **Source Packages**（源码包）：包含软件源代码、版本修改说明、构建指令以及==编译工具==等。==先由tar工具归档为.tar.gz文件，然后再打包成.dsc文件==。

```shell
软件包类型的查询命令 file

kidea@Linux:~$ file  g++_4.1.2-9ubuntu2_i386.deb
g++_4.1.2-9ubuntu2_i386: Debian binary package (format 2.0)
```

### 软件包命名规范

```she
Filename_Version-Reversion_Architecture.deb
软件包名称_软件版本-修订版本_系统内核架构.deb


```

### 软件源

>  根据软件包的开发组织对该软件的支持程度，以及遵从的开源程度，划分为如下四类：

- **核心（Main）**：官方维护的开源软件，是由Ubuntu官方完全支持的软件，包括大多数流行的、稳定的开源软件，是Ubuntu默认安装的基本软件包；

- **公共（Universe）**：社区维护的开源软件，是由Ubuntu社区的计算机爱好者维护的软件。这些软件包没有安全升级的保障。用户在使用时，需要考虑这些软件包存在的不稳定性；

- **受限（Restricted）**：官方维护的非开源软件，是专供特殊用途，而且没有自由软件版权，不能直接修改软件，但依然被Ubuntu团队支持的软件；

- **多元化（Multiverse）**：非Ubuntu官方维护的非开源软件，用户使用这些软件包时，需要特别注意版权问题。

### dpkg软件包管理器

> 所有源自“Debian”的“Linux”发行版都使用dpkg，例如Ubuntu、Knoppix等。

1. **功能**：dpkg主要用于==本地软件包==的管理。它侧重于安装、卸载和提供.deb软件包相关的信息。

2. 常用命令

   - 安装本地存在的软件：`dpkg -i <package_name>.deb`

   - 列出已安装的包列表：`dpkg -l`

   - 查看包的安装路径：`dpkg -L <package_name>`

   - 查看包是否安装：`dpkg -s <package_name>` 或 `dpkg --status <package_name>`

   - 查找指定文件所属的包名：`dpkg -S <file_name>` 或 `dpkg --search <file_name>`

   - `dpkg -r <package> ` 移除一个已经安装的软件包

   - `dpkg -P <package>`  移除已安装软件包及配置文件

     

### 软件包管理工具APT

> ATP软件包管理器的作用
>
> - **检查和修复软件包依赖关系**
> - **利用Internet网络帮助用户主动获取软件包**

> apt是基于dpkg的软件包管理工具，可以理解为dpkg的“前端”或“升级版”。apt不仅提供了与dpkg类似的软件包管理功能，还增加了远程包的下载和依赖管理。

1. **功能**：apt会解决和安装模块的依赖问题，并会咨询软件仓库。它侧重于远程包的下载和依赖管理，使得用户可以更方便地安装、更新和卸载软件包。
2. ==常用命令：==
   - 更新包信息：`sudo apt update`
   - 升级包：`sudo apt upgrade`
   - 安装包：`sudo apt install <package_name>`
   - 删除不再需要的依赖包：`sudo apt autoremove`

> 
>
> Ubuntu的软件源配置文件路径为`/etc/apt/sources.list` 

- 软件源配置文件只是告知Ubuntu系统可以访问的==镜像站点(服务器)地址==。

- 镜像站点没有软件资源的列表。
- APT为这些软件资源建立了索引文件，以便本地主机查询。

- 修改==sources.list==内的镜像源换为国内源可以提高访问速度

#### apt-get包更新命令：

使用`apt-get update`命令会扫描每一个软件源服务器，并为该服务器所具有软件包资源建立索引文件，存放在本地的/var/lib/apt/lists/目录中

#### apt-get命令格式：

```shell
apt-get  subcommands  [ -d | -f | -m | -q | --purge | --reinstall | - b | - s | - y | - u | - h | -v ]  pkg
```

| subcommands(子命令) | 描述                                   |
| ------------------- | -------------------------------------- |
| **update**          | 下载更新软件包列表信息                 |
| **upgrade**         | 将系统中所有软件包升级到最新的版本     |
| **install**         | 下载所需软件包并进行安装配置           |
| **remove**          | 卸载软件包                             |
| **autoremove**      | 将不满足依赖关系的软件包自动卸载       |
| **source**          | 下载源码包                             |
| **build-dep**       | 为源码包构建所需的编译环境             |
| **dist-upgrade**    | 发布版升级                             |
| **dselect-upgrade** | 根据dselect的选择来进行软件包升级      |
| **clean**           | ==删除缓存区中所有已下载的包文件==     |
| **autoclean**       | 删除缓存区中==老版本==的已下载的包文件 |
| **check**           | ==检查==系统中==依赖==关系的完整性     |

| 选项        | 描述                                              |
| ----------- | ------------------------------------------------- |
| -d          | 仅下载软件包，而不安装或解压                      |
| -f          | ==修复系统中存在的软件包依赖性问题==              |
| -m          | 当发现缺少关联软件包时，仍试图继续执行            |
| -q          | 将输出作为日志保留，不获取命令执行进度            |
| --purge     | ==与remove子命令一起使用，完全卸载软件包==        |
| --reinstall | ==与install子命令一起使用，重新安装软件包==       |
| -b          | 在下载完源码包后，编译生成相应的软件包            |
| -s          | 不做实际操作，只是模拟命令执行结果                |
| -y          | 对所有询问都作肯定的回答，apt-get不再进行任何提示 |
| -u          | 获取已升级的软件包列表                            |
| -h          | 获取帮助信息                                      |
| -v          | 获取apt-get版本号                                 |

#### apt-cache获取软件包详细信息

`apt-cache show`命令获取指定软件包的详细信息，包括软件包安装状态、优先级、适用架构、版本、存在依赖关系的软件包，以及功能描述。该命令可以同时显现多个软件包的详细信息。 

#### apt-cache 命令格式:

```shell
apt-cache  subcommands  [ -p | -s | - q | - i | - c | -h ]  pkg
```

| 子命令   | 描述                           |
| -------- | ------------------------------ |
| showpkg  | 获取二进制软件包的常规描述信息 |
| showsrc  | 获取源码包的详细描述信息       |
| show     | 获取二进制软件包的详细描述信息 |
| stats    | 获取软件源的基本统计信息       |
| search   | 根据正则表达式检索软件包       |
| depends  | 获取该软件包的依赖信息         |
| rdepends | 获取所有依赖于该软件包的软件包 |
| pkgnames | 列出所有已安装软件包的名字     |
| policy   | 获取软件包当前的安装状态       |

## Shell命令

**shell****简介**

- **命令**是用户向系统内核发出控制请求，与之交互的文本流。

- shell是一个命令行解释器，将用户命令解析为操作系统所能理解的指令，实现用户与操作系统的交互。

- 当需要重复执行若干命令，可以将这些命令集合起来，加入一定的控制语句，编辑成为**shell****脚本**文件，交给shell批量执行。 
