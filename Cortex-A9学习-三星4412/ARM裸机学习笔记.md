## ARM裸机开发

- 华清远见-Linux-武老师

**Linux方向课程结构**

<img src="../assets/ARM裸机学习笔记/image-20240723082824239.png" alt="image-20240723082824239" style="zoom: 55%;" />

![image-20240723085556383](../assets/ARM裸机学习笔记/image-20240723085556383.png)

- 目前课程处于底层开发的第一阶段，**ARM**裸机开发
- 学习过程中不要过多深入到其他课程
- 学习方法<img src="../assets/ARM裸机学习笔记/image-20240723085932075.png" alt="image-20240723085932075" style="zoom:30%;" />

# day01 计算机硬件基础



## Linux的结构框架

<img src="../assets/ARM裸机学习笔记/image-20240723083952473.png" alt="image-20240723083952473" style="zoom:35%;" />

**Linux子系统**

  1.进程管理：管理进程的创建、调度、销毁等

  2.内存管理：管理内存的申请、释放、映射等

  3.文件系统：管理和访问磁盘中的文件

  4.设备管理：硬件设备及驱动的管理（==本次课程的重点==）

  5.网络协议：通过网络协议栈(TCP、IP...)进行通信

## 计算器基础知识

<img src="../assets/ARM裸机学习笔记/image-20240723090616192.png" alt="image-20240723090616192" style="zoom:60%;" />

- 具体的二进制信号的电平由**通信协议**或**电平规范**确定

## 冯诺依曼-计算机架构

![image-20240723090924301](../assets/ARM裸机学习笔记/image-20240723090924301.png)

**输入设备**

-  把其他信号转换成计算机能识别和处理的信号并送入计算机中 如键盘、鼠标、摄像头等

 **输出设备**

-  把运算结果以人或其他设备所能接受的形式送出计算机外  如显示器、音响、打印机等

**存储器**

-  存储器是用来存储程序和数据的部件,是实现"存储程序控制"的基础如内存、硬盘等

**运算器**

-  CPU中负责进行算数运算和逻辑运算的部件，其核心是算术逻辑单元ALU

**控制器**

-  控制器是CPU的指挥中心,其控制着整个CPU执行程序的逻辑过程

> 注：运算器和控制器共同组成了CPU

## 总线

<img src="../assets/ARM裸机学习笔记/image-20240723091739184.png" alt="image-20240723091739184" style="zoom:50%;" />

**总线**

- 总线是计算机中各个部件之间传送信息的公共通信干线,
- 在物理上就是一束导线按照其传递信息的类型可以分为==数据总线、地址总线、控制总线==

**DMA总线**

- DMA(Direct Memory Access)即直接存储器访问
- 使用DMA总线可以==不通过CPU==直接在存储器之间进行数据传递

---



## 三级存储结构

- 实际**计算机存储器**比较复杂一般是==**三级存储器**==（普通单片机一般只有一个存储器）

- 使用三级存储结构是为了兼顾**速度、容量、价格**
- **CPU不能直接读写硬盘**

<img src="../assets/ARM裸机学习笔记/image-20240723093019277.png" alt="image-20240723093019277" style="zoom:35%;" />

**Cache**（高速缓存）

- ==速度最快==、价格最贵、容量最小、断电数据==丢失==、cpu可直接访问

-  存储当前正在执行的程序中的活跃部分,以便快速地向CPU提供指令和数据

**主存储器**

- 速度、价格、容量介于Cache与辅存之间、断电数据==丢失==、cpu可直接访问

-  存储当前正在执行的程序和数据

- 相当于==内存==，可以一次读写==1Byte==，但是内存容量较小

**辅助存储器**

- 速度最慢、价格最低、容量最大、断电数据==不丢失==、cpu不可直接访问

- 存储暂时不运行的程序和数据，需要时再传送到主存

- 相当于==硬盘==，硬盘属于**块设备**，例如：可能一次只能读写512KB，具体设备存在差异

## 地址空间

<img src="../assets/ARM裸机学习笔记/image-20240723094104243.png" alt="image-20240723094104243" style="zoom:33%;" />

**地址空间**

-  一个处理器能够**访问**（读写）的存储空间是有限的,我们称这个空间为它的地址空间（**寻址空间**）

- 一般来说N位（bit）地址总线的处理器的地址空间是2的N次方

  - 一条总线只能读写 1bit 数据

  - **32位**系统地址空间为 2^32bit=**4GB**

  - 64位系统地址空间理论上为 2^64bit=16EiB

  - 实际上Linux 64位系统通常只使用低48位来描述虚拟内存空间，这意味着寻址范围为2^48，即256TB。

## CPU工作原理

- 一个**CPU核**一次只能执行一条指令
- 每执行一条指令后**PC**的值会**自动增加**指向下一条指令

<img src="../assets/ARM裸机学习笔记/image-20240723100642657.png" alt="image-20240723100642657" style="zoom:20%;" />

**一条指令的执行分为三个阶段**

  **1.取址：** **PC**发送地址给内存，内存返回地址中的指令，**IR**接收指令的过程称为取址

  **2.译码：** 指令译码器对 **IR** 中的指令进行识别，将 **指令（机器码）**解析成具体的运算

  **3.执行：**控制器控制运算器中对应的**运算单元**进行运算，运算结果写入寄存器

---





# day02 ARM处理器概论

---



## ARM简介

ARM（Advanced RISC Machines)

- 一家公司的名称
- 一种CPU的架构
- 一种技术的名称

### **ARM公司**

- 成立于1990年11月，前身为Acorn计算机公司

- 主要设计ARM系列RISC处理器内核

- 授权ARM内核给生产和销售半导体的合作伙伴，ARM公司并不生产芯片

- 提供基于ARM架构的开发设计技术软件工具、评估板、调试工具、应用软件、总线架构、外围设备单元等

### ARM架构

基于ARM架构定义指令集和==编程模型==（基本数据类型、工作模型、寄存器组）

### SOC(System on Chip)

- 即片上系统，将一个系统中所需要的全部部件集成在一个芯片中在体积、功耗、价格上有很大优势
- CPU是SOC的核心

<img src="../assets/ARM裸机学习笔记/image-20240723105048004.png" alt="image-20240723105048004" style="zoom:70%;" />

### ARM架构的版本

   V1-V3 最早的版本，目前已废弃

   V4-V6 经典处理器中运用的比较多

   V7 目前Cortex系列处理器主要是这种架构、支持Thumb-2的32位指令集（Cortex-M4就是这个版本）

   V8 兼容ARMv7架构的特性，并支持64位数据处理

### ARM的三个系列

##### Cortex-M 

为单片机驱动的系统提供的低成本优化方案，应用于传统

的微控制器市场，智能传感器，汽车周边部件等。

##### Cortex-A 

针对开放式操作系统的高性能处理器；

应用于智能手机，数字电视，服务器等高端运用。 

##### Cortex-R 

针对实时系统、满足实时性、高可靠性控制需求；

应于汽车制动系统，动力系统，移动通信基带控制器等。

---



## 指令集

###### 概念

- ==**CPU**==能够识别并执行的**指令集合**；

- 一个指令对应一个物理上的**运算电路**

- 每一条指令可处理一个简单或复杂操作（加、乘、积分…）；

- 指令在**内存**中以机器码（**二进制**）的方式存在

- 每一条指令对应一条**汇编指令**

- 指令是对硬件电路的抽象

- 程序是指令的有序集合

###### 分类

- **精简指令集（RISC）：**
  - 指令简单而有效，格式和长度通常是固定的，大多数指令在一个周期内可以执行完毕，（ARM内核基于RISC）
  - 只保留常用的的简单指令，硬件结构简单，复杂操作一般通过简单指令的组合实现，一般指令长度固定，且多为单周期指令
  -  RISC处理器在功耗、体积、价格等方面有很大优势，所以在嵌入式移动终端领域应用极为广泛
- **复杂指令集（CISC）**
  - 包含处理复杂操作的特定指令，指令长度不固定，执行需要多个周期。（X86架构）
  - 不仅包含了常用指令，还包含了很多不常用的特殊指令，硬件结构复杂，指令条数较多，一般指令长度和周期都不固定
  -   CISC处理器在性能上有很大优势，多用于PC及服务器等领域

### **ARM处理器都支持两种指令集：**

- **ARM指令集**（==课程重点==）

  - 所有指令（机器码）都占用**32bit**存储空间

  - 代码灵活度高、简化了解码复杂度

  - 执行ARM指令集时PC值每次自增4

- **Thumb指令集**

  -  所有指令（机器码）都占用**16bit**存储空间

  - 代码密度高、节省存储空间

  - 执行Thumb指令集时PC值每次自增2

## **编译原理**

![image-20240723111027582](../assets/ARM裸机学习笔记/image-20240723111027582.png)

- 机器码（二进制）是处理器能直接识别的语言
  - 不同的机器码代表不同的运算指令
  - 处理器能够识别哪些机器码是由处理器的硬件设计所决定的
  - 不同的处理器机器码不同，所以机器码不可移植

- 汇编语言是机器码的符号化
  - 即汇编就是用一个符号来代替一条机器码
  - 所以不同的处理器汇编也不一样，即汇编语言也不可移植

- C语言在编译时我们可以使用不同的编译器将C源码编译成不同架构处理器的汇编，所以C语言可以移植

## ARM存储模型

**ARM采用32位架构，基本数据类型只有三种**

> 因为总线是32bit，所以一次只能处理23bit的数据

### 基本数据类型

- **Byte               8bits  = 1byte**

- **Halfword     16bits = 2byte**  （半字）

- **Word            32bits = 4byte**     （字）

### **数据存储**

- 内存中一个地址代表==1byte==
- ==**规定：**==数据本身是多少位在内存存储时就应该多少位==对齐==

- **Halfword**型数据在内存的**起始地址**==必须==是（十进制）**2**的**整数倍**
- **Word**型数据在内存的**起始地址**==必须==是（十进制）**4**的**整数倍**

<img src="../assets/ARM裸机学习笔记/image-20240723113338702.png" alt="image-20240723113338702" style="zoom:40%;" />

> 用16进制表示内存地址时，一个单位长度等于4bit，每进一位增加4bit，即**每进2位增加一个字节**

### 字节序

> 在Linux网络编程课程中有详细讲解
>
> 只占用一个字节的数据没有字节序

**大端对齐**

- 低地址存放高位，高地址存放低位

```c
a = 0x 1234 5678 ;
1234是高位  5678是低位
序号小的地址称为低地址，一般从上往下地址依次变高
```

**小端对齐**

-  低地址存放低位，高地址存放高位
- ==ARM一般使用小端对齐==（路由器之类是大端对齐）

 ```c
 a = 0x 1234 5678 ;
 Ubuntu是小端对齐，即取a的地址读到的是78
 ```



### 指令存储

**处理器处于ARM指令状态时**

- 指令长度是32bit

-  所有指令在内存的起始地址必须是（十进制）4的整数倍

-  PC值由其[31:2]位决定，[1:0]位未定义，即PC只看前面的高30位地址，后面的低2位地址会强制为00
- 因为合法地址一定是（十进制）4的整数倍，而4的整数倍转换为二进制后低2位都是00
- 给PC输入非法地址时候，CPU会把低2位地址会强制置为00

**处理器处于Thumb指令状态时**

- 指令长度是16bit

- 所有指令在内存的起始地址必须是（十进制）2的整数倍

- PC值由其[31:1]位决定，[0]位未定义
- 同理，给PC输入非法地址时候，CPU会把低1位地址会强制置为0

## ARM工作模式

**ARM-Cortex-A9 有8个基本的工作模式**

  

| 模式    | 说明                                                |
| ------- | --------------------------------------------------- |
| User    | 非特权模式，一般在执行上层的应用程序时ARM处于该模式 |
| FIQ     | 当一个高优先级中断产生后ARM将进入这种模式           |
| IRQ     | 当一个低优先级中断产生后ARM将进入这种模式           |
| SVC     | 当复位或执行==软中断==指令后ARM将进入这种模式       |
| Abort   | 当产生存取异常时ARM将进入这种模式                   |
| Undef   | 当执行未定义的指令时ARM将进入这种模式               |
| System  | 使用和User模式相同寄存器集的特权模式                |
| Monitor | 为了安全而扩展出的用于执行安全监控代码的模式        |

> 注意，操作系统的**内核态和用户态**不等于处理器的**工作模式**
>
> 不用背，中断后面会详细介绍

- 不同模式拥有不同**权限**

- 不同模式**执行**不同代码

- 不同模式完成不同的**功能**

### 工作模式分类

**按照权限**分类

- User为非特权模式（权限较低）

- 其余模式均为特权模式（权限较高）

 **按照状态**分类

- FIQ、IRQ、SVC、Abort、Undef属于异常模式
- 即当处理器遇到异常后会进入对应的模式

# day03 ARM寄存器组织

**概念：**这里是的寄存器是**CPU内部**的存储器，==没有地址==

**作用：**一般用于**暂时存**放参与运算的**数据**和运算**结果**

> C语言中的registe类型的变量就是存在CPU内部的寄存器，而不是内存
>
> 所以不用取址，CPU可以直接用

**分类**

- 通用寄存器
- 专用寄存器
- 控制寄存器

![image-20240723191036075](../assets/ARM裸机学习笔记/image-20240723191036075.png)

- 所谓工作模式的**权限**，就是可以用的寄存器不一样
- 在某个特定模式下只能使用当前模式下的寄存器
- 一个模式下特有的寄存器其他模式下不可使用



---



## 专用寄存器

**R15   (别称  PC  , Program Counter)**

- 程序计数器，用于存储当前取址**指令的地址**

- 默认情况下PC会自动增加4 bytes（下一条指令），也可以用汇编给PC赋值

**R14(  LR ,  ink Register)**

  链接寄存器，一般有以下两种用途：

-  ==主动==执行跳转指令(BL/BLX)时，LR会**自动保存**跳转指令**下一条指令**的地址
  - 程序需要返回时将LR的值复制到PC即可实现

- ==被动==产生异常（中断）时，对应异常模式下的LR会**自动保存**被异常打断的指令的**下一条**指令的地址
  - 异常处理结束后将LR的值复制到PC可实现程序返

**R13(  SP  ,  Stack Pointer)**

  栈指针，用于存储当前模式下的栈顶地址

 局部变量、函数参数、函数返回值等一些临时数据存在**栈**里

栈的本质就是一段内存，而==SP==存放的就是栈的起始地址（**栈顶地址**）



## 控制寄存器

**CPSR**    (Current Program Status Register)，  **当前程序状态寄存器** 

- CPSR一共是32 bits，常用的是**低8位**、**高4位**

![image-20240723193136112](../assets/ARM裸机学习笔记/image-20240723193136112.png)

**Bit[4:0]**    低5位控制CPU的工作模式

  [10000]=User 

  [10001]=FIQ 

  [10010]=IRQ  

  [10011]=SVC

  [10111]=Abort 

  [11011]=Undef 

  [11111]=System 

  [10110]=Monitor

**Bit[5]**    第6位控制指令集模式

  [0]ARM状态   [1]Thumb状态

**Bit[6]**  第7位控制高优先级中断

  [0]开启FIQ   [1]禁止FIQ

**Bit[7]**   第8位控制低优先级中断

  [0]开启IRQ   [1]禁止IRQ

**Bit[28]** 

- 当运算器中进行加法运算且产生符号位进位时该位自动置1，否则为0
- 当运算器中进行减法运算且产生符号位借位时该位自动置0，否则为1

**Bit[29]** 

- 当运算器中进行加法运算且产生进位时该位自动置1，否则为0
- 当运算器中进行减法运算且产生借位时该位自动置0，否则为1

**Bit[30]** 

- 当运算器中产生了0的结果该位自动置1，否则为0

**Bit[31]** 

- 当运算器中产生了负数的结果该位自动置1，否则为0

---



# day04 ARM异常处理